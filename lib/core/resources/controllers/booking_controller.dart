import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:get/get.dart';
import 'package:silid/core/resources/models/bookings.dart';
import 'package:silid/core/utility/widgets/snackbar.dart';
import 'package:silid/core/views/student/index.dart';

class BookingController extends GetxController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  var bookings = <Bookings>[].obs;
  final RxBool isLoading = false.obs;

  Future<void> createBooking({
    required String student,
    required String teacher,
    required DateTime date,
    required String lesson,
    required String meetingLink,
  }) async {
    try {
      isLoading.value = true;

      // Get Firestore autogenerated document ID
      DocumentReference bookingRef = _firestore.collection('bookings').doc();
      String bookingId = bookingRef.id; // Firestore-generated UID

      // Create a booking instance
      Bookings newBooking = Bookings(
        uid: bookingId,
        student: student,
        teacher: teacher,
        date: date,
        status: {'message': 'Booked', 'remarks': ''}, // Default status
        lesson: lesson,
        meetingLink: meetingLink,
      );

      // Save to Firestore with autogenerated UID
      await bookingRef.set(newBooking.toFirestore());

      isLoading.value = false;
      Get.off(() => const StudentIndex());
      SnackbarWidget.showSuccess("Schedule booked Succesfully");
    } catch (e) {
      isLoading.value = false;
      SnackbarWidget.showError("Failed to create booking $e");
    }
  }

  Future<void> fetchAllBookings() async {
    try {
      isLoading.value = true;
      QuerySnapshot querySnapshot =
          await _firestore.collection('bookings').get();
      bookings.value =
          querySnapshot.docs.map((doc) => Bookings.fromFirestore(doc)).toList();
    } catch (e) {
      SnackbarWidget.showError("Failed to load booking $e");
    } finally {
      isLoading.value = false;
    }
  }

  void fetchBookings({String? studentName, String? teacherName}) {
    try {
      isLoading.value = true;

      Query query = _firestore.collection('bookings');

      // Apply filter based on the provided parameter
      if (studentName != null) {
        query = query.where('student', isEqualTo: studentName);
      } else if (teacherName != null) {
        query = query.where('teacher', isEqualTo: teacherName);
      }

      // Listen for real-time changes instead of fetching once
      query.snapshots().listen((snapshot) {
        bookings.value =
            snapshot.docs.map((doc) => Bookings.fromFirestore(doc)).toList();

        isLoading.value = false;
        update(); // ðŸš€ Ensure UI updates automatically
      }, onError: (error) {
        isLoading.value = false;
        SnackbarWidget.showError("Failed to cancel booking $error");
      });
    } catch (e) {
      isLoading.value = false;
      SnackbarWidget.showError("Failed to cancel booking $e");
    }
  }

  void cancelBooking(String remarks, String bookingId) async {
    if (remarks.isNotEmpty) {
      try {
        await FirebaseFirestore.instance
            .collection('bookings')
            .doc(bookingId)
            .update({
          'status': {
            'message': 'Cancelled',
            'remarks': remarks,
          },
        });

        SnackbarWidget.showSuccess("Booking cancellation success!");
      } catch (e) {
        SnackbarWidget.showError("Failed to cancel booking $e");
      }
    } else {
      Get.snackbar("Error", "Please provide a cancellation reason.");
    }
  }

  void finishBooking(String bookingId) async {
    try {
      await FirebaseFirestore.instance
          .collection('bookings')
          .doc(bookingId)
          .update({
        'status': {
          'message': 'Finished',
          'remarks': '',
        },
      });
      SnackbarWidget.showSuccess("Booking finished!");
    } catch (e) {
      SnackbarWidget.showError("Failed to finish booking");
    }
  }
}
